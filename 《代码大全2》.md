#目录  

- [第一章 欢迎进入软件构建的世界](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第一章-欢迎进入软件构建的世界)  
- [第二章 用隐喻来更充分地理解软件开发](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二章-用隐喻来更充分地理解软件开发)  
- [第三章 三思而后行：前期准备](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第三章-三思而后行前期准备)  
- [第四章 关键的“构建”决策](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第四章-关键的构建决策)  
- [第五章 软件构建中的设计](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第五章-软件构建中的设计)  
- [第六章 可以工作的类](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第六章-可以工作的类)  
- [第七章 高质量的子程序](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第七章-高质量的子程序)  
- [第八章 防御式编程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第八章-防御式编程)  
- [第九章 伪代码编程过程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第九章-伪代码编程过程)  
- [第十章 使用变量的一般事项](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十章-使用变量的一般事项)  
- [第十一章 变量名的力量](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十一章-变量名的力量)  
- [第十二章 基本数据类型](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十二章-基本数据类型)  
- [第十三章 不常见的数据类型](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十三章-不常见的数据类型)  
- [第十四章 组织直线型代码](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十四章-组织直线型代码)  
- [第十五章 使用条件语句](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十五章-使用条件语句)  
- [第十六章 控制循环](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十六章-控制循环)  
- [第十七章 不常见的控制结构](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十七章-不常见的控制结构)
- [第十八章 表驱动法](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十八章-表驱动法)  
- [第十九章 一般控制问题](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十九章-一般控制问题)  
- [第二十章 软件质量概述](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二十章-软件质量概述)  
- [第二十一章 协同构建](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二十一章-协同构建)  
- [第二十二章 开发者测试](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二十二章-开发者测试)  
- [第二十三章 调试](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二十三章-调试)  
- [第二十四章 重构](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二十四章-重构)  
- [第二十五章 代码调整策略](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二十五章-代码调整策略)  
- [第二十六章 代码调整技术]()


> 第一遍阅读中  


# 第一章 欢迎进入软件构建的世界  
- 软件构建，是重中之重  


# 第二章 用隐喻来更充分地理解软件开发  
- 隐喻即建模，诸如地心说，日心说之类。  
- 对于开发一个不大的项目，增量式开发是首选，即牡蛎的珍珠养殖。而一个大型项目，则需要一开始就仔细地规划，即建房子。 


# 第三章 三思而后行：前期准备  
- 准备工作的中心就是降低风险，在实现一个项目时，你需要理解“这个系统应该做什么”，以及“它该如何做到这些”。  
- appeal to Data：原则在于，发现错误的时间要尽可能接近引入错误的时间。  
- 在开始编程之前，确认你的“需求”是否到位。  


# 第四章 关键的“构建”决策  
主要的构建实践：  
- 编码  
- 团队工作  
- 质量保证  
- 工具  


# 第五章 软件构建中的设计  
开发中一般所遇到的问题，都来源于项目的复杂性。软件的首要技术使命就是管理复杂度。用下面两个方法进行复杂度管理：  
&emsp;1. 把任何人在同一时间需要处理的本质复杂度的量减到最少  
&emsp;2. 不要让偶然性的复杂度无谓地快速增长  
设计的层次：  
&emsp;1. 第一层 软件系统  
&emsp;2. 第二层 分解为子系统或包  
&emsp;&emsp;不同子系统之间的相互通信要分隔开  
&emsp;3. 第三层 分解为类  
&emsp;&emsp;如果项目较小，可直接从第一层跳至第三层  
&emsp;4. 第四层 分解成子程序  
&emsp;5. 第五层 子程序内部的设计  

低耦合：耦合度表示类与类之间或者子程序与子程序之间关系的紧密程度  
高内聚：类内部的子程序或者子程序内所有代码在支持一个中心目标上的紧密程度  


# 第六章 可以工作的类  
- 抽象数据类型(ADT, abstract data type)是指一些数据以及对这些数据所进行操作的集合。  
- 创建一个高质量的类，首先要定义一个良好的接口。  
&emsp;1. 当一个类中出现大量子程序时，把这些子程序重新组织，职能相近的分类到一个更专一的类中。  
&emsp;2. 良好的封装。  
- 包含：有一个。。。的关系；继承：是一个。。。的关系。


# 第七章 高质量的子程序  
- 在子程序层上的设计  
&emsp;1. 功能上的内聚性；  
&emsp;&emsp;让一个子程序仅执行一项操作。  
&emsp;2. 顺序上的内聚性；  
&emsp;&emsp;指在子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成了一项完整的功能。  
&emsp;3. 通信上的内聚性；  
&emsp;&emsp;指一个子程序的不同操作使用了相同的数据，但不存在其他任何联系。  
&emsp;4. 临时的内聚性；  


# 第八章 防御式编程  
- 主要思想：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。  
- 三钟方法来处理外来的非法数据：  
&emsp;1. 检查所有来源于外部的数据的值；  
&emsp;2. 检查子程序所有输入参数的值；  
&emsp;3. 决定如何处理错误的输入数据；  
- 断言是用来觉迟绝不应该发生的状况，而错误处理代码来处理预期会发生的状况。  
- 因地制宜的进行防御式编程。  


# 第九章 伪代码编程过程   
- "伪代码"指用来描述算法，子程序，类或完整程序的工作逻辑，非形式的，类似于英语的记法。个人理解，即将设计的逻辑写下来。然后对照着逻辑，去修改，去实现。  


# 第十章 使用变量的一般事项  
- 变量初始化注意以下错误  
&emsp;1. 从未对变量赋值。它的值只是程序启动时变量所处内存区域的值。  
&emsp;2. 变量值已经过期。变量在某个地方曾经被赋值，但该值已经不再有效。  
&emsp;3. 变量的一部分被赋值，而另一部分没有。  
- 作用域  
&emsp;1. 使变量引用局部化  
&emsp;2. 尽可能缩短变量的存活时间  
- 减小作用域的一般原则  
&emsp;1. 在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序开始处初始化这些变量。  
&emsp;2. 直到变量即将被使用时再为其赋值。  
&emsp;3. 把相关语句放到一起。  
&emsp;4. 把相关语句提取成单独的子程序。  
&emsp;5. 开始时采用最严格的可见性，然后根据需要扩展变量的作用域。  


# 第十一章 变量名的力量  
- 变量名要能够完全，准确地描述出该变量所代表的事物。  
- 需要避免的名字：  
&emsp;1. 令人误解的名字或缩写；  
&emsp;2. 具有相似含义的名字；  
&emsp;3. 具有不同含义但却有相似名字的变量；  
&emsp;4. 发音相似的名字；  
&emsp;5. 在名字中使用数字；  
&emsp;6. 在名字中拼错单词；  
&emsp;7. 不要仅靠大小写来区分变量名；  
&emsp;8. 使用多种自然语言；  
&emsp;9. 名字中包含易混淆的字符。  


# 第十二章 基本数据类型  
- 数值概论  
&emsp;1. 避免使用“神秘数值”:(指程序中出现的，没有经过解释的数值文字量)  
&emsp;2. 如果需要，可以使用硬编码的0和1；  
&emsp;3. 预防除零错误；  
&emsp;4. 使类型转换的明显；  
&emsp;5. 避免混合类型的比较；  
- 整数  
&emsp;1. 检查整数除法和溢出；  
&emsp;2. 检查中间溢出；  
- 浮点数  
&emsp;1. 避免数量级相差巨大的数之间的加减运算  
&emsp;2. 避免等量判断；  
&emsp;3. 处理舍入误差；  
- 字符串  
&emsp;1. 避免off-by-one(偏差一)错误，即因索引产生的错误；
&emsp;2. 熟悉unicode转换之类的操作；
- 使用枚举，来代替多个if判断，switch-case之类；  
- 数组  
&emsp;1. 确认数组下标没有超出边界；  
&emsp;2. 考虑用容器来取代数组，或将数组作为顺序化结构来处理(如集合，栈，队列等)；  
&emsp;3. 检查数组边界点；  
&emsp;4. 如果数组是多维的，确认下标的使用顺序是正确的；  
- 创建自定义数据类型的指导原则  
&emsp;1. 给所创建的类型取功能导向的名字；  
&emsp;2. 避免使用预定义类型；  
&emsp;3. 不要重定义一个预定义的类型；  
&emsp;4. 定义代替类型以便于移植；  
&emsp;5. 建议使用一个类；  


# 第十三章 不常见的数据类型  
- 结构体  
Python本身实木有的，但struct模块起到了与C交互的这个功能。  
- 全局变量  
尽量避免使用全局变量，尝试用子程序来取代全局变量。  


# 第十四章 组织直线型代码
- 必须有明确顺序的语句：  
&emsp;1. 设法组织代码，是依赖关系变得非常明显；  
&emsp;2. 使子程序名能凸显依赖关系；  
&emsp;3. 使子程序参数；  
&emsp;4. 利用子程序参数明确显示依赖关系；  
&emsp;5. 用注释对不清晰的依赖关系进行说明；  
&emsp;6. 用断言或者错误处理密码来检查依赖关系；  
- 对于顺序无关的语句：  
&emsp;1. 使代码易于自上而下地阅读；  
&emsp;2. 把相关语句组织在一起；  


# 第十五章 使用条件语句  
- if-else:  
&emsp;1. 把正常情况的处理放在if后面而不要放在else后面；  
&emsp;2. 让if子句后面跟随一个有意义的语句；  
- case语句；  
&emsp;1. 为case选择最有效的排列顺序；  
&emsp;2. 把default子句只用于检查真正的默认情况；  


# 第十六章 控制循环  
- 当不知道要循环迭代多少次时使用while循环，并且决定是在循环开始处还是结尾处检测；  
- 执行固定次数的循环时使用for循环；  
- 关于循环控制：  
&emsp;1. 减少能影响该循环各种因素的数量；  
&emsp;2. 把循环内部当成一个字程序来看待；  
- 进入循环  
&emsp;1. 只从一个位置进入循环；  
&emsp;2. 把初始化代码紧放在循环前面；  
&emsp;3. 用while(true)表示无限循环，Python用while 1比较好;  
&emsp;4. 在适当情况下多使用for循环；  
&emsp;5. 在while循环更实用的时候，不要使用for循环；  
- 循环该有多长：  
&emsp;1. 循环尽可能短，以便能够一目了然；  
&emsp;2. 把嵌套限制在3层以内，如果超过，应该把一部分提取为子程序；  
&emsp;3. 把长循环的内容移到子程序里；  
&emsp;4. 让长循环格外清晰；  


# 第十七章 不常见的控制结构  
- 子程序中多处返回  
&emsp;1. 用防卫子句(早返回或早退出)来简化复杂的错误处理  
&emsp;2. 减少每个子程序中return的数量  
- 递归的使用技巧  
&emsp;1. 确认递归能够停止  
&emsp;2. 把递归限制在一个子程序内  


# 第十八章 表驱动法  
表驱动法是一种编程模式(scheme)---从表里面查找信息而不使用逻辑语句(if和case).  
&emsp;1. 从表中查询数据的方法：  
&emsp;2. 直接访问  
&emsp;&emsp;此处的表并不单指数据库中的表，也可以是一大堆子程序在程序中构成的表；  
&emsp;3. 索引访问  
&emsp;&emsp;即按索引进行快速查询；  
&emsp;4. 阶梯访问  
&emsp;&emsp;表中的记录对不同的数据范围有效，而不是对不同的数据点有效；  


# 第十九章 一般控制问题  
- 布尔表达式  
&emsp;1. 用true和false做布尔判断；  
&emsp;2. 简化复杂的表达式；  
&emsp;&emsp;拆分复杂的判断并引入新的布尔变量；  
&emsp;&emsp;把复杂表达式做成布尔函数；  
&emsp;3. 编写肯定形式的布尔表达式, 即条件判断设为肯定句；  
- 结构化编程  
&emsp;三要素：顺序，选择，迭代  
- 降低复杂度  
&emsp;将子程序的一部分提取成另一个子程序，它不会降低整个程序的复杂度，但可以降低你头脑中考虑项目的数量。  


# 第二十章 软件质量概述  
- 改善软件质量的技术  
&emsp;1. 软件质量目标  
&emsp;2. 明确定义质量保证工作  
&emsp;3. 测试策略  
&emsp;4. 软件工程指南  
&emsp;5. 非正式技术复查  
&emsp;6. 正式技术复查  
&emsp;7. 外部审查  


# 第二十一章 协同构建  
- 协同开发实践概要  
&emsp;协同构建思想在于：工作人员总会对某些错误点视而不见，而其他人不会有相同的盲点。  
- 结对编程  
&emsp;即一位程序员敲代码，一位程序员注意有没有出现错误；  
- 正式检查  
&emsp;详查专注于缺陷的检测，详查表关注复查者过去所遇到的问题；  
 

# 第二十二章 开发者测试  
- 测试分为两大类：黑盒测试和白盒测试；  
- 推荐使用测试先行(TDD)；  
- 结构化基础测试：你需要去测试程序中每一条语句至少一次；  
- 数据流测试：数据使用出错的几率至少不亚于控制流；  
- 大部分错误都会集中在一部分子程序中，避免陷入那些烦人的子程序中；  
- 改善测试过程，进行有计划的测试；  
- 保留测试记录，留下相应的测试数据；  


# 第二十三章 调试  
调试指确定错误的根本原因并纠正此错误的过程。  
- 寻找缺陷：  
&emsp;1. 将错误状态稳定下来  
&emsp;2. 确定错误来源  
&emsp;&emsp;a. 收集产生缺陷的相关数据，  
&emsp;&emsp;b. 分析所收集的数据， 并构造对缺陷的假设，  
&emsp;&emsp;c. 确定怎样去证实或证伪这个假设，可以对程序进行测试或通过检查代码，  
&emsp;&emsp;d. 按照2(c)确定的方法对假设做出最终结论；  
&emsp;3. 修补缺陷；  
&emsp;4. 对所修补的地方进行测试；  
&emsp;5. 查找是否还有类似错误；  
- 修正缺陷：  
&emsp;1. 动手之前先要理解问题和程序本身；  
&emsp;2. 保存最初的源代码；  
&emsp;3. 治本，而不是治标；  
&emsp;4. 一次只做一个改动；  
- 将编译器警告级别设为最严格，把警告信息所报告的错误都改正。如果你忽略了明显的错误，那么要改正那些微妙的错误就会非常麻烦；  


# 第二十四章 重构  
- 软件演化的基本准则：演化应当提升程序的内在质量；  
- 重构：在不改变软件外部行为的前提下，对其内部结构进行改变；  
- 数量级的重构：  
&emsp;1. 用具名常量替代神秘数值；  
&emsp;2. 使变量名字清晰并传递更多信息；  
&emsp;3. 用函数代替表达式；  
&emsp;4. 用多个单一用途变量代替某个多用途变量；  
&emsp;5. 将一组类型码转换为一个基类及其相应派生类；  
- 语句级重构：  
&emsp;1. 分解布尔表达式；  
&emsp;2. 将复杂布尔表达式转换为命名准确的布尔表达式；  
&emsp;3. 合并条件语句不同部分中的重复代码片段；  
&emsp;4. 使用break或return而不是循环控制变量；  
&emsp;5. 用多态来替代条件语句；  
- 子程序重构：  
&emsp;1. 提取子程序或方法；  
&emsp;2. 将子程序代码内联化；  
&emsp;3. 将长子程序转化为类；  
&emsp;4. 增加或删除参数；  
&emsp;5. 将查询操作从修改操作中独立出来；  
&emsp;6. 合并相似的子程序，通过参数区分它们的功能；  
&emsp;7. 将行为取决于参数的子程序拆分开来；  
- 类实现的重构：  
&emsp;1. 改变成员函数或成员数据的位置；  
&emsp;2. 将相似代码结合起来放置到基类中；  
- 安全的重构：  
&emsp;1. 保存初始代码；  
&emsp;2. 重构的步伐请小些；  
&emsp;3. 同一时间只做一项重构；  
&emsp;4. 设置一个停车场，即发现有一个更好的办法；  
&emsp;5. 根据重构的风险级别来调整重构方法；  


# 第二十五章 代码调整策略  
关于性能问题，要从两个方面去考虑：策略上和技术上；  
- 性能和代码调整  
&emsp;1. 程序需求，即程序要求在1s内搞定，但实际情况是90%只需在4s内搞定，这里面可以鼓捣；  
&emsp;2. 程序设计，一开始便从性能角度考虑；  
&emsp;3. 同操作系统的交互；  
&emsp;4. 代码编译，比如pypy；  
&emsp;5. 硬件，至尊e5八路泰坦；  
&emsp;6. 代码调整，指较小规模修改；  
- pareto法则  
20%的代码占据了程序80%的时间，so，集中火力对付这20%；  
- 代码调整方法总结  
&emsp;1. 用设计良好的代码来开发软件，从而使程序易于理解和修改；  
&emsp;2. 如果程序很差：  
&emsp;&emsp;a. 保存程序的可运行版本；  
&emsp;&emsp;b. 对系统进行分析测量，找出热点；  
&emsp;&emsp;c. 判断性能低下是否源于设计，数据类型或算法上的缺陷，确定是否应该做代码调整，如果不是，请跳回第一步；  
&emsp;&emsp;d. 对步骤c中所确定的瓶颈代码进行调整；  
&emsp;&emsp;e. 每次调整后对性能提升进行测试；  
&emsp;&emsp;f. 如果调整没有改进代码的性能，就恢复到步骤a保存的代码；  
&emsp;3. 重复步骤2；  


# 第二十六章 代码调整技术  
- 逻辑  
&emsp;1. 知道答案后就停止判断，即短路求值；  
&emsp;2. 按结果出现的频率来调整判断顺序；  
&emsp;3. 用查询表替代复杂表达式；  
&emsp;4. 使用惰性求值，即每次只处理需要处理的部分；  
- 循环  
&emsp;1. 将判断外提(即循环运行时某个判断条件不会变，就把这个判断提到循环外面)；  
&emsp;2. 将相似循环合并；  
&emsp;3. 尽可能减少在循环中的工作；  
&emsp;4. 设置哨兵值用以保证循环一定能停止，一般这个值放在开始的复合判断中；  
&emsp;5. 将最忙的循环放在最内层；  
- 数据变换  
&emsp;1. 尽量使用整型数；  
&emsp;2. 数组维度尽可能少；  
&emsp;3. 使用辅助索引，这些索引指向关键点或特定区域；  
&emsp;4. 使用缓存机制；  
- 表达式  
&emsp;1. 利用代数恒等式(a and not b == (a or b),但后者更快)；  
&emsp;2. 削减运算强度；  
&emsp;3. 编译初始化，如果一神秘数值是不变的，那用常量代替它；  
&emsp;4. 小心系统函数；  
&emsp;5. 将需要多次使用的计算结果保存下来；  
- 子程序  
将良好的子程序拆解；  
- 用低级语言重写代码  
