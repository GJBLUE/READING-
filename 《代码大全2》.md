#目录  

- [第一章 欢迎进入软件构建的世界](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第一章-欢迎进入软件构建的世界)  
- [第二章 用隐喻来更充分地理解软件开发](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二章-用隐喻来更充分地理解软件开发)  
- [第三章 三思而后行：前期准备](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第三章-三思而后行前期准备)  
- [第四章 关键的“构建”决策](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第四章-关键的构建决策)  
- [第五章 软件构建中的设计](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第五章-软件构建中的设计)  
- [第六章 可以工作的类](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第六章-可以工作的类)  
- [第七章 高质量的子程序](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第七章-高质量的子程序)  


- [第十八章 表驱动法](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十八章-表驱动法)  

# 第一章 欢迎进入软件构建的世界  
软件构建，是重中之重  

# 第二章 用隐喻来更充分地理解软件开发  
- 隐喻即建模，诸如地心说，日心说之类。  
- 对于开发一个不大的项目，增量式开发是首选，即牡蛎的珍珠养殖。而一个大型项目，则需要一开始就仔细地规划，即建房子。 

# 第三章 三思而后行：前期准备  
- 准备工作的中心就是降低风险，在实现一个项目时，你需要理解“这个系统应该做什么”，以及“它该如何做到这些”。  
- appeal to Data：原则在于，发现错误的时间要尽可能接近引入错误的时间。  
- 在开始编程之前，确认你的“需求”是否到位。  

# 第四章 关键的“构建”决策  
主要的构建实践：  
- 编码  
- 团队工作  
- 质量保证  
- 工具  

# 第五章 软件构建中的设计  
开发中一般所遇到的问题，都来源于项目的复杂性。软件的首要技术使命就是管理复杂度。用下面两个方法进行复杂度管理：  
&emsp;1. 把任何人在同一时间需要处理的本质复杂度的量减到最少  
&emsp;2. 不要让偶然性的复杂度无谓地快速增长  
设计的层次：  
&emsp;1. 第一层 软件系统  
&emsp;2. 第二层 分解为子系统或包  
&emsp;&emsp;不同子系统之间的相互通信要分隔开  
&emsp;3. 第三层 分解为类  
&emsp;&emsp;如果项目较小，可直接从第一层跳至第三层  
&emsp;4. 第四层 分解成子程序  
&emsp;5. 第五层 子程序内部的设计  

低耦合：耦合度表示类与类之间或者子程序与子程序之间关系的紧密程度  
高内聚：类内部的子程序或者子程序内所有代码在支持一个中心目标上的紧密程度  

# 第六章 可以工作的类  
- 抽象数据类型(ADT, abstract data type)是指一些数据以及对这些数据所进行操作的集合。  
- 创建一个高质量的类，首先要定义一个良好的接口。  
&emsp;1. 当一个类中出现大量子程序时，把这些子程序重新组织，职能相近的分类到一个更专一的类中。  
&emsp;2. 良好的封装。  
- 包含：有一个。。。的关系；继承：是一个。。。的关系。

# 第七章 高质量的子程序  
- 在子程序层上的设计  
&emsp;1. 功能上的内聚性；  
&emsp;&emsp;让一个子程序仅执行一项操作。  
&emsp;2. 顺序上的内聚性；  
&emsp;&emsp;指在子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成了一项完整的功能。  
&emsp;3. 通信上的内聚性；  
&emsp;&emsp;指一个子程序的不同操作使用了相同的数据，但不存在其他任何联系。  
&emsp;4. 临时的内聚性；  




# 第十八章 表驱动法  
表驱动法是一种编程模式(scheme)---从表里面查找信息而不使用逻辑语句(if和case).  
从表中查询数据的方法：  
- 直接访问  
- 索引访问  
- 阶梯访问  
