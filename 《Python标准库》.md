> 10月份重新补习了Python基础，今天来开始补习标准库，就这么一路背下来。凡是自己不会的都记录下来，熟悉下. 优先处理自己要学习的东西。  

# 目录  

- [第一章 文本](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第一章-文本)  
&emsp;- [1.1 string-文本常量和模块](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#11-string-文本常量和模块)  
&emsp;- [1.2 textwrap---格式化文本段落](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#12-textwrap---格式化文本段落)  
&emsp;- [1.4 difflib---比较序列](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#14-difflib---比较序列)  

- [第二章 数据结构](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第二章-数据结构)  
&emsp;- [2.1 collections--容器数据类型](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#21-collections--容器数据类型)  
&emsp;- [2.2 array--固定类型数据序列](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#22-array--固定类型数据序列)  
&emsp;- [2.5 Queue--线程安全的FIFO实现](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#25-queue--线程安全的fifo实现)  
&emsp;- [2.6 struct--二进制数据结构]()  

- [第三章 算法](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第三章-算法)  
&emsp;- [3.2 itertools--迭代器函数](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#32-itertools--迭代器函数)  
&emsp;- [3.4 contextlib--上下文管理器工具](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#34-contextlib--上下文管理器工具)  

- [第四章 日期和时间](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第四章-日期和时间)  
&emsp;- [4.1 time--时钟时间](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#41-time--时钟时间)  
&emsp;- [4.2 datetime--日期和时间值管理](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#42-datetime--日期和时间值管理)  

- [第五章 数学计算](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第五章-数学计算)  
&emsp;- [5.3 random--伪随机数生成器](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#53-random--伪随机数生成器)  
&emsp;- [5.4 math--数学函数](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#54-math--数学函数)  

- [第六章 文件系统](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第六章-文件系统)  
&emsp;- [6.1 os.path--平台独立的文件名管理](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#61-ospath--平台独立的文件名管理)  
&emsp;- [6.3 linecache--高效读取文件](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#63-linecache--高效读取文件)  
&emsp;- [6.4 tempfile--临时文件系统对象](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#64-tempfile--临时文件系统对象)  
&emsp;- [6.5 shutil--高级文件操作](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#65-shutil--高级文件操作)  
&emsp;- [6.7 codecs--字符串编码和解码](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#67-codecs--字符串编码和解码)  
&emsp;- [6.8 StringIO--提供类文件API的文本缓冲区](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#68-stringio--提供类文件api的文本缓冲区)  
&emsp;- [6.10 dircache--缓存目录列表](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#610-dircache--缓存目录列表)  
&emsp;- [6.11 filecmp--比较文件](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#611-filecmp--比较文件)  

- [第七章 数据持久存储与交换](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第七章-数据持久存储与交换)  
&emsp;- [7.1 pickle--对象串行化](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#71-pickle--对象串行化)  
&emsp;- [7.7 csv--逗号分隔值文件](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#77-csv--逗号分隔值文件)  

- [第八章 数据压缩与归档](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第八章-数据压缩与归档)  
&emsp;- [8.4 tarfile--Tar归档访问](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#84-tarfile--tar归档访问)  
&emsp;- [8.5 zipfile--ZIP归档访问](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#85-zipfile--zip归档访问)  

- [第九章 加密](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第九章-加密)  
&emsp;- [9.1 hashlib--密码散列](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#91-hashlib--密码散列)

- [第十章 进程与线程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第十章-进程与线程)  
&emsp;- [10.1 subprocess---创建附加进程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#101-subprocess---创建附加进程)  
&emsp;- [10.3 threading--管理并发操作](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#103-threading--管理并发操作)  
&emsp;- [10.4 multiprooessing--像线程一样管理进程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#104-multiprooessing--像线程一样管理进程)  

- [第十一章 网络通信](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第十一章-网络通信)  
&emsp;- [11.1 socket--网络通信](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#111-socket--网络通信)

- [第十二章 Internet](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第十二章-internet)  
&emsp;- [12.3 urllib--网络资源访问](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#123-urllib--网络资源访问)  
&emsp;- [12.4 urllib2--网络资源访问](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#124-urllib2--网络资源访问)  
&emsp;- [12.9 json--JavaScript对象记法](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#129-json--javascript对象记法)  

- [第十四章 应用构建模块](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第十四章-应用构建模块)  
&emsp;- [14.7 shlex--解析shell](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#147-shlex--解析shell)  
&emsp;- [14.9 日志--报告状态、错误和信息消息](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#149-日志--报告状态错误和信息消息)  
&emsp;- [14.11 atexit--程序关闭回调](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#1411-atexit--程序关闭回调)  

- [第十六章 开发工具](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第十六章-开发工具)  
&emsp;- [16.3 unittest--自动测试框架](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#163-unittest--自动测试框架)  
&emsp;- [16.4 traceback---异常和栈轨迹](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#164-traceback---异常和栈轨迹)  
&emsp;- [16.6 pdb--交互式调试工具](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#166-pdb--交互式调试工具)  

- [第十七章 运行时特性](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#第十七章-运行时特性)  
&emsp;- [17.2 sys--系统特定的配置](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#172-sys--系统特定的配置)  
&emsp;- [17.3 os--可移植访问操作系统特定特性](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B.md#173-os--可移植访问操作系统特定特性)  


# 第一章 文本  

### 1.1 string-文本常量和模块  

- 函数  
&emsp;string.capitalize() -> string;Return a copy of the string S with only its first character capitalized.  
&emsp;string.maketrans(frm, to) -> string;Return a translation table (a string of 256 bytes long):  
&emsp;S.translate(table [,deletechars]) -> string;根据table表来进行转换，比replace要高效.  

- 模板  
&emsp;string.Template();这个方法类似于%s这种，但是用$var这种方式来标志变量，输入的变量形式为字典，即values = {'var':'lol'},这个样子。之后还需要String.substitute()来实现。
```Python  
values = {'var':'lol'}

t = string.Template("""
val : $var
""")

t.substitute(values)
Out[27]: '\nval : lol\n'
```  
模版和标准字符串最大的的区别在于:*模版中值会先转化为字符串，以字符串形式插入*，使用**safe_substitute()**可以捕获参数不对时的异常。  

- 高级模板  
&emsp;加入了正则，进行替换。  

### 1.2 textwrap---格式化文本段落  
- 填充段落  
textwrap.fill(text, width=70, **kwargs),Fill a single paragraph of text, returning a new string.  
- 去除现有缩进  
textwrap.dedent(text),Remove any common leading whitespace from every line in `text`.  

### 1.4 difflib---比较序列  
difflib模块包含一些用来计算和处理序列之间差异的工具  
- 比较文本体  
```Python
In [1]: t1 = '123456789'

In [2]: t2 = '1234asd89'

In [3]: import difflib 

In [4]: d = difflib.Differ()

In [5]: diff = d.compare(t1, t2)

In [6]: print '\n'.join(diff)
  1
  2
  3
  4
- 5
- 6
- 7
+ a
+ s
+ d
  8
  9

In [7]: s = difflib.unified_diff(t1, t2, lineterm='',)

In [8]: print '\n'.join(list(diff))


In [9]: print '\n'.join(list(s))
--- 
+++ 
@@ -2,8 +2,8 @@
 2
 3
 4
-5
-6
-7
+a
+s
+d
 8
 9

```  

- 忽略无用数据  
```Python
from difflib import SequenceMatcher

s = SequenceMatcher(lambda x: x == " ",
                    "private Thread currentThread;",
                    "private volatile Thread currentThread;")

print (s.find_longest_match(0, 20, 0, 20))
Match(a=0, b=0, size=8)
```  

- 比较任意类型  
```Python
In [1]: from difflib import SequenceMatcher

In [2]: t1 = ' qwer'

In [3]: t2 = 'asdf asdf'

In [4]: match = SequenceMatcher(None, t1, t2)

In [5]: match.get_opcodes()
Out[5]: [('insert', 0, 0, 0, 4), ('equal', 0, 1, 4, 5), ('replace', 1, 5, 5, 9)]
```  


# 第二章 数据结构  

### 2.1 collections--容器数据类型  

- 2.1.1 Counter  
Counter作为一个容器，可以跟踪相同的值增加了多少次。这个类可以用来实现其他语言中常用包(bag)或多集合(multiest)数据结构来实现算法。  
构造一个空Counter,然后通过update()方法填充。  
```Python
In [1]: import collections

In [2]: c = collections.Counter()

In [3]: c
Out[3]: Counter()

In [4]: c.update(a=1)

In [5]: c
Out[5]: Counter({'a': 1})
```  
elements()方法返回一个迭代器，将生成Counter知道的所有元素。ps:不保证元素顺序不变  
```Python
In [6]: c = collections.Counter('happy coding')

In [7]: list(c.elements())
Out[7]: ['a', ' ', 'c', 'd', 'g', 'i', 'h', 'o', 'n', 'p', 'p', 'y']
```  
most_common()可以生成一个序列，其中包含n个最常遇到的输入值及其相对应计数。  
```Python
In [6]: c = collections.Counter('happy coding')

In [8]: c.most_common(3)
Out[8]: [('p', 2), ('a', 1), (' ', 1)]

In [9]: c.most_common()  #不提供参数会形成一个list给出
Out[9]: 
[('p', 2),
 ('a', 1),
 (' ', 1),
 ('c', 1),
 ('d', 1),
 ('g', 1),
 ('i', 1),
 ('h', 1),
 ('o', 1),
 ('n', 1),
 ('y', 1)]
```  
Counter实例支持算术和集合操作来完成结果的聚集。  

- 2.1.2 defaultdict  
collections.defaultdict会返回一个类似dictionary的对象，注意是类似的对象，不是完全一样的对象。这个defaultdict和dict类，几乎是一样的，除了它重载了一个方法和增加了一个可写的实例变量。collections.defaultdict(list)和dict.setdefault()等价，但是要更快。并且defaultdict可以利用工厂函数，给初始key带来一个默认值。  

- 2.1.3 deque  
deque支持从任意一端增加和删除函数。更为常用的两种结构，即栈和队列。PS:deque是线程安全的。  
append()从右侧添加,appendleft()从左侧添加。pop()从右侧删除,popleft()从左侧添加。extend等同理.  
```Python
In [1]: import collections

In [2]: d = collections.deque('o')

In [3]: d.append('l')

In [4]: d
Out[4]: deque(['o', 'l'])

In [5]: d.appendleft('l')

In [6]: d
Out[6]: deque(['l', 'o', 'l'])

In [7]: d.
d.append      d.count       d.maxlen      d.remove      
d.appendleft  d.extend      d.pop         d.reverse     
d.clear       d.extendleft  d.popleft     d.rotate   
```  
deque可以向任意一个方向旋转，可以理解为拨号盘。  
```Python
In [10]: d = collections.deque(xrange(10))

In [11]: d
Out[11]: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [12]: d.rotate(2)

In [13]: d
Out[13]: deque([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])

In [14]: d.rotate(-4)

In [15]: d
Out[15]: deque([2, 3, 4, 5, 6, 7, 8, 9, 0, 1]) 
```  

- 2.1.4 namedtuple  
namedtuple除了指定数值索引外，还会指定名字。  

- 2.1.5 OrderedDict  
常规dict不跟踪插入顺序，OrderedDict中则相反，它会记住元素插入的顺序，并在创建迭代器时使用这个顺序。  


### 2.2 array--固定类型数据序列  

- 2.2.1 init  
```Python
In [3]: import array

In [5]: s = 'this is'

In [6]: a = array.array('c', s)

In [7]: a
Out[7]: array('c', 'this is')
```  

- 2.2.2 处理数组  
```Python
In [8]: a = array.array('i', xrange(3))

In [9]: a
Out[9]: array('i', [0, 1, 2])

In [10]: a.extend(xrange(3))

In [11]: a
Out[11]: array('i', [0, 1, 2, 0, 1, 2])

In [12]: a[2:5]
Out[12]: array('i', [2, 0, 1])

In [13]: list(enumerate(a))
Out[13]: [(0, 0), (1, 1), (2, 2), (3, 0), (4, 1), (5, 2)]

In [14]: list(a)
Out[14]: [0, 1, 2, 0, 1, 2]
```  

- 2.2.3 数组与文件  
```Python
import array
import binascii
import tempfile

a = array.array('i', xrange(5))

output = tempfile.NamedTemporaryFile()
a.tofile(output.file)
output.flush()

with open(output.name, 'rb') as input:
    raw_data = input.read()
    input.seek(0)
    a2 = array.array('i')
    a2.fromfile(input, len(a))
```  

### 2.5 Queue--线程安全的FIFO实现  

- 2.5.1 基本FIFO队列  
先进先出，使用put()将元素增加到序列异端，用get()从另一端删除。  

- 2.5.2 LIFO队列  
后进先出  

### 2.6 struct--二进制数据结构  
有的时候需要用python处理二进制数据，比如，存取文件，socket操作时.这时候，可以使用python的struct模块来完成.可以用 struct来处理c语言中的结构体.  

- 2.6.2 打包和解包  
Struct支持使用格式指示符将数据打包(packing)为字符串，以及从字符串解包(unpacking)数据。  
```Python
In [1]: import struct

In [2]: import binascii

In [3]: values = (1, 'ab', 2.7)

In [4]: s = struct.Struct('I 2s f')

In [6]: packed_data = s.pack(*values)  #打包

In [7]: s.format
Out[7]: 'I 2s f'

In [8]: s.size  #size指代缓存区需要有多大
Out[8]: 12

In [9]: binascii.hexlify(packed_data)  #hexlify转换为16进制  
Out[9]: '0100000061620000cdcc2c40'  

In [10]: data = binascii.unhexlify('0100000061620000cdcc2c40')

In [11]: unpack_data = s.unpack(data)  # unpack

In [12]: unpack_data
Out[12]: (1, 'ab', 2.700000047683716)
```  

- 2.6.3 字节序  
即形如**('<I', args)**这个形式，<表示顺序，I指代C语言中的数据类型。  
| Character   | Byte order                         |
| :---------- | :--------------------------------: |
| @           | native                             |
| =           | native                             |
| <           | little-endian                      |
| >           | big-endian                         |
| !           | network (= big-endian)             |


# 第三章 算法  

### 3.2 itertools--迭代器函数  

- 3.2.1 合并并分解迭代器  
chain()函数取多个迭代器作为参数，最后返回一个迭代器。
```Python
In [15]: from itertools import *

In [16]: for i in chain([1,2,3],['a', 'b', 'c']):
   ....:     print i,
1 2 3 a b c

In [17]: chain([1,2,3],['a', 'b', 'c'])
Out[17]: <itertools.chain at 0x7ff7e7ea6a10>
```  
izip()返回一个迭代器，它会把多个迭代器的元素结合到一个元祖中。  
```Python
In [18]: for i in izip([1,2,3], ['a', 'b', 'c']):
   ....:     print i 
(1, 'a')
(2, 'b')
(3, 'c')
```

- 3.2.2 转换输入  
imap()函数会返回一个函数其，它对输入迭代器中的值调用一个函数并返回结果。  
```Python
In [19]: for i in imap(lambda x:2*x, xrange(5)):
   ....:     print i  
0
2
4
6
8
```  
starmap()函数使用*语法分解一个迭代器中的元素作为映射函数的参数。  
```Python
In [22]: for i in starmap(lambda x,y:(x, y, x*y), values):
   ....:     print '%d * %d = %d' %i  
0 * 5 = 0
1 * 6 = 6
2 * 7 = 14
3 * 8 = 24
4 * 9 = 36
```  

- 3.2.3 生成新值  
count()返回一个迭代器，能够无限生成连续整数。  
cycle()返回一个迭代器，会无限地重复给定参数的内容。  
repeat()返回的迭代器会一直返回数据，可选times参数来限制次数。    

- 3.2.4 过滤  
dropwhile()返回一个迭代器，它会生成输入迭代器中条件第一次为false之后的元素。  
takewhile()与dropwhile()正好相反。  

- 3.2.5 数据分组  
groupby()函数返回一个迭代器，它会生成按一个公共键组织的值集。  


### 3.4 contextlib--上下文管理器工具  

- 3.4.2 从生成器到上下文管理器  
可以使用contextmanager()修饰符将一个生成器函数转换为上下文管理器。  
```Python
import contextlib

@contextlib.contextmanager
def make_context():
    pass
```  
看了一圈，没打看懂，暂时自己只有用with。嗯，放在这，下次再说。  


# 第四章 日期和时间  

### 4.1 time--时钟时间  

- 4.4.1 壁挂钟时间  
time.time()原来返回的是纪元开始到现在的时间。  
```Python
In [1]: import time

In [2]: time.time()
Out[2]: 1452647474.660122

In [3]: time.ctime()
Out[3]: 'Wed Jan 13 09:11:18 2016'

In [4]: time.clock()  #clock()返回处理器时钟时间
Out[4]: 0.595312
```  

- 4.1.3 时间组成  
```Python
In [1]: import time

In [8]: time.gmtime()
Out[8]: time.struct_time(tm_year=2016, tm_mon=1, tm_mday=13, tm_hour=1, tm_min=16, tm_sec=17, tm_wday=2, tm_yday=13, tm_isdst=0)

In [12]: s = time.gmtime()
s.tm_hour   s.tm_mday   s.tm_mon    s.tm_wday   s.tm_year   
s.tm_isdst  s.tm_min    s.tm_sec    s.tm_yday   

In [14]: s.tm_year
Out[14]: 2016
```  

- 4.1.5 解析和格式化时间  
time模块提供了两个函数striptime()和strftime()，实现了struct_time和时间值字符串表示之间转换。  
```Python
In [1]: import time

In [15]: now = time.ctime()

In [16]: p = time.strptime(now)

In [17]: p
Out[17]: time.struct_time(tm_year=2016, tm_mon=1, tm_mday=13, tm_hour=9, tm_min=30, tm_sec=55, tm_wday=2, tm_yday=13, tm_isdst=-1)

In [18]: time.strftime("%a %b %d %H:%M:%S %Y", p)
Out[18]: 'Wed Jan 13 09:30:55 2016'
```  

### 4.2 datetime--日期和时间值管理  

- 4.2.1 时间  
time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --> a time object  
```Python
In [1]: import datetime

In [2]: t = datetime.time()
t.dst          t.max          t.minute       t.second       t.tzname
t.hour         t.microsecond  t.replace      t.strftime     t.utcoffset
t.isoformat    t.min          t.resolution   t.tzinfo     
```  

- 4.2.2 日期  
```Python
In [1]: import datetime

In [7]: today = datetime.date.today()

In [8]: today
Out[8]: datetime.date(2016, 1, 13)

In [11]: today = datetime.datetime.today()

In [12]: today
Out[12]: datetime.datetime(2016, 1, 13, 9, 42, 38, 621284)  
```  

- 4.2.4 日期算术运算  
```Python
In [1]: import datetime

In [12]: today
Out[12]: datetime.datetime(2016, 1, 13, 9, 42, 38, 621284)

In [13]: oneday = datetime.timedelta(days=1)

In [14]: yesterday = today - oneday

In [15]: yesterday
Out[15]: datetime.datetime(2016, 1, 12, 9, 42, 38, 621284) 
```  

- 4.2.7 格式化和解析  
和time模块类似  



# 第五章 数学计算  

### 5.3 random--伪随机数生成器  

- 5.3.1 生成随机数  
random.random()生成随机数，ranom.uniform(1，100)可以指定范围。  

- 5.3.2 指定种子  
random.seed()值会控制生成伪随机数所用公式产生的第一个值，即下一次循环后，生成的都是一样的。  

- 5.3.4 随机整数  
random.randint(1, 100)生成整数，random.ranrange(1, 100, 5)。

- 5.3.5 选择随机元素  
random.choice()  


### 5.4 math--数学函数  

- 5.4.3 转换为整数  
trunc()，会截断小数点后的数字；floor()将其输入转换为不大于他的最大整数；ceil()(上限)会生成按顺序排在这个输入值之后的最小整数。  

- 5.4.4 正号和负号   
fabs()可以计算一个浮点数的绝对值.


# 第六章 文件系统  

### 6.1 os.path--平台独立的文件名管理  
- 6.1.1 解析路径  
路径解析依赖于os中定义的一些变量  
&emsp;- os.sep--路径各部分之间的分隔符("/"or"\")  
&emsp;- os.extsep--文件名与文件“扩展名”之间的分隔符(".")  
&emsp;- os.pardir--路径中表示目录树上一级的部分("..")  
&emsp;- os.curdir--路径中指示当前目录的部分(".")  
os.path.split()函数将路径分解为两个单独的部分，并返回包含这些结果的一个tuple。这个tuple的第二个元素是路径的最后一部分，第一个元素则是最后这个部分之前的所有内容。  
```Python
In [5]: import os.path

In [6]: for path in ['/one/two',
   ...:              '/one/two/',
   ...:              '/',
   ...:              '.',
   ...:              '']:
   ...:     print '%s: %s'%(path, os.path.split(path))
   ...:     
/one/two: ('/one', 'two')
/one/two/: ('/one/two', '')
/: ('/', '')
.: ('', '.')
: ('', '') 
```  
os.path.basename()返回的值等价于os.path.split()值的第二部分，而os.path.basename()值则对应第一部分。  
os.path.splitext()会根据扩展名分隔符来分割路径。  
```Python  
In [5]: import os.path

In [8]: for path in ['f.txt',
             'f',
             '/s/f.txt',
             'sss.',
             '',]:
    print '%s: %s'%(path, os.path.splitext(path))  
f.txt: ('f', '.txt')
f: ('f', '')
/s/f.txt: ('/s/f', '.txt')
sss.: ('sss', '.')
: ('', '')
```  
os.path.commonprefix()可以获得所有路径中都出现的公共前缀，但这个前缀不一定存在。  

- 6.1.2 建立路径  
os.path.join()知道，目前用这个也够用了。  
os.apth.expanduser()可以将波浪线(~)转换为用户主目录。如果找不到用户主目录，则字符串不做任何改动直接返回  
os.path.expandvars()会扩展路径中出现的所有shell环境变量  

- 6.1.3 规范化路径  
os.path.normpath可以清除路径中多余的分隔符或相对路径。  
```Python  
In [9]: os.path.normpath('o/./123//')
Out[9]: 'o/123'
```  
os.path.abspath()可以将一个相对路径转化为绝对路径  
```Python  
In [10]: os.path.abspath('/code')
Out[10]: '/code'

In [11]: os.path.abspath('./code')
Out[11]: '/home/jblue13/code'

In [12]: os.path.abspath('../code')
Out[12]: '/home/code'
```  

- 6.1.4 文件时间  
&emsp;- os.path.getatime()返回访问时间  
&emsp;- ospath.getmtime()返回修改时间  
&emsp;- os.path.getctime()返回创建时间  
&emsp;- os.path.getsize()返回文件中的数据量，尝试了下对文件夹使用显示的都是4096(UNIX下)，推测只可以对文件使用。  

- 6.1.5 测试文件  
这一块方法比较多，自己有用过：os.path.isfile(), os.path.isdir(), os.path.exists(),其他用到了再说。  

- 6.1.6 遍历一个目录树  
介绍的os.path.walk()方法，但查阅了一些资料之后，os.walk()要更优一些。  
os.walk明显比os.path.walk要简洁一些，起码它不需要回调函数，遍历的时候一目了然：root，subdirs，files。 


### 6.3 linecache--高效读取文件  

- 6.3.1 获取全部文件  
linecache.getlines(filename)  
从名为filename的文件中得到全部内容，输出为列表格式，以文件每行为列表中的一个元素,并以linenum-1为元素在列表中的位置存储.  
```Python  
In [10]: linecache.getlines(fine)
Out[10]: ['2\n', '3\n', '4\n', '5\n', '6\n', '67\n', 'tf wef\n', '234\n']
```  
**注意：使用linecache.getlines('a.txt')打开文件的内容之后，如果a.txt文件发生了改变，如你再次用linecache.getlines获取的内容，不是文件的最新内容，还是之前的内容，此时有两种方法：  
1、使用linecache.checkcache(filename)来更新文件在硬盘上的缓存，然后在执行linecache.getlines('a.txt')就可以获取到a.txt的最新内容；  
2、直接使用linecache.updatecache('a.txt')，即可获取最新的a.txt的最新内容  
另：读取文件之后你不需要使用文件的缓存时需要在最后清理一下缓存，使linecache.clearcache()清理缓存，释放缓存。**  

- 6.3.2 读取特定行  
linecache.getline(filename,lineno)  
从名为filename的文件中得到第lineno行。这个函数从不会抛出一个异常–产生错误时它将返回”（换行符将包含在找到的行里）。**如果文件没有找到，这个函数将会在sys.path搜索，即在标准库中查找。**  
返回值通常在行末尾都包括一个换行符，所以如果文本行为空，那么返回值就是一个换行符。  

- 6.3.5 读取Python源文件  
linecache在生成traceback跟踪路径时使用相当频繁，其关键特性就是能够通过指定模块的基名在导入路径中查找Python源模块。  
```Python  
import linecache  
import os  
module_line = linecache.getline('linecache.py', 3)

print repr(module_line)
file_src = linecache.__file__  
if file_src.endswith('.pyc'):
    file_src = file_src[:-1]
with open(file_src, 'r') as f:
    file_line = f.readlines()[2]
print repr(file_line)
```  


### 6.4 tempfile--临时文件系统对象  

- 6.4.1 临时文件  
TemporaryFile()函数会创建文件，该文件会在关闭时自动删除。ps:TemporaryFile()返回的文件没有文件名  
```Python  
import tempfile

temp = tempfile.TemporaryFile()
```  
默认地，文件句柄采用模式'w+b'，写文件之后，必须使用seek()"回转"文件句柄。  
```Python  
import tempfile

with tempfile.TemporaryFile() as temp:
    temp.write('some data')
    temp.seek(0)
    print temp.read()

with tempfile.TemporaryFile(mode='w+t') as f:
    f.writelines(['first\n', 'second\n'])
    f.seek(o)

    for line in f:
        print line.rstrip()
```  

- 6.4.2 命名文件  
NamedTemporaryFile()函数会创建一个文件，但不会断开其连接，可以用name属性访问到。  

- 6.4.3 临时文件  
mkdtemp()创建一个临时目录，并打开该目录中的所有文件。  

- 6.4.5 临时文件位置  
如果没使用dir参数指定明确的位置，则gettempdir()返回包含所有临时文件的默认目录，gettempprefix()返回新文件和目录名的字符串前缀。  


### 6.5 shutil--高级文件操作  

- 6.5.1 复制文件  
copyfilr()将源的内容复制到目标，如果没有权限写木匾文件则产生IOError  
```Python  
from shutil import * 

copyfile('sss.py', 'sss.py.copy')
```  
copyfile()的实现使用了底层函数copyfileobj().copyfile()的参数是文件名，但copyfileobj()的参数是打开的文件句柄。还可以有第三个参数：用于读入块的一个缓冲区长度。默认是大数据块读取，使用-1会一次读入所有输入，使用正数可以设置特定的块大小。  
类似于UNIX命令行工具cp，copy()函数会用同样的方式解释输出名。如果指定的目标指示一个目录而不是一个文件，会使用源文件的基名在该目录中穿件一个新文件。文件的权限会随内容复制  
```Python  
from shutil import * 
import os

os.mkdir('example')
copyfile('sss.py', 'example')
print os.listdir('example')

['sss.py']
```  
copy2()的工作类似于copy(),不过复制到新文件的元数据中会包含访问和修改时间。

- 6.5.2 复制文件元数据  
默认地，在UNIX下创建一个新文件时，他会根据当前用户的umask接受权限。要把权限从一个文件复制到另一个文件，可以使用copymode().  
copystat()智慧复制与文件关联的权限和日期。  

- 6.5.3 处理目录树  
shutil包含3个函数用来处理目录树。要把一个目录从一个位置复制到另一个位置，可以使用copytree，当然，目标目录不能已存在。  
```Python  
from shutil import * 

copytree('../shutil', '/tmp/example')
```  
要删除一个目录及其中的内容，用rmtree()。默认地，错误会作为异常产生，不过如果第二个参数为true，就可以忽略这些异常。可以在第三个参数中提供一个特殊的错误处理函数。  
```Python  
from shutil import * 

rmtree('/tmp/example')
```  
move()的语义与UNIX命令mv类似，如果源和目标都在同一个文件系统内，则会重命名源文件。否则，源文件会复制到目标文件，然后将源文件删除。  
```Python  
from shutil import * 

move('example.txt', 'example.out')
```  

### 6.7 codecs--字符串编码和解码  
codecs模块提供了刘接口和文件接口来转换数据。通常用于处理Unicode文本，不过也提供了其他编码来满足其他用途。  

- 6.7.2 处理文件  
open(filename, mode='rb', encoding=None, errors='strict', buffering=1)  
Open an encoded file using the given mode and return a wrapped version providing transparent encoding/decoding.  
PS:**必须提前知道编码，才能正确地建立解码器。**  

- 6.7.3 字节序  
在不同计算机系统之间传输数据时，多字节编码(如UTF-16和UTF-32)会引发一个问题。不同系统中使用的高字节和低字节的顺序不同。数据的这个特性，称为字节序。通常没办法提前知道给定的一组数据要使用哪一种字节序，所以多字节编码还包含一个字节序标志(BOM)，这个标志出现在编码输出的前几个字节。如，UTF-16和UTF-32所用字节序标志的相应常量.  


### 6.8 StringIO--提供类文件API的文本缓冲区  
该模块可以用来处理内存中的文本,用cStringIO好。  
```Python  
try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

output = StringIO()
output.write('This goes into the buffer')

print output.getvalue()
output.close()

input = StringIO('Inital value for read buffer')
print input.read()
```  

### 6.10 dircache--缓存目录列表  
dircache模块从文件系统读取目录列表，并保存在内存中。  

- 6.10.1 列出目录内容  
dircache.listdir()作用和os.listdir()一样。  

- 6.10.2 标注列表  
annotate()，它会修改list()(如listdir()返回的list)，向表示目录的名称末尾增加一个"/"。


### 6.11 filecmp--比较文件  

- 6.11.2 比较文件  
```Python  
In [1]: import filecmp

In [2]: print filecmp.cmp('1.txt', '2.txt', shallow=False)
```  
shallow参数告诉cmp()除了文件的元数据外，是否还要查看文件的内容。  
如果非递归地比较两个目录的一组文件，可以使用cmpfiles()。参数是目录名和两个位置上要检查的文件列表。cmpfiles()将返回3个文件名列表，分别包含匹配的文件、不匹配的文件和不能比较的文件。  

- 6.11.3 比较目录   
```Python  
In [1]: import filecmp

In [3]: filecmp.dircmp('home/dir1', 'home/dir2').report()
```  
report()显示的结果只包括给定目录的内容，而不会递归比较其子目录，report_full_closure()能得到更详细的递归比较。  



# 第七章 数据持久存储与交换  

### 7.1 pickle--对象串行化  
pickle模块实现了一个算法可以将一个任意的Python对象转换为一系列字节。这个过程也称为串行化对象。表示对象的字节流可以传输或存储，然后重新构造来创建有相同性质的新对象。(注意用cPickle,方法是一样的)  

- 7.1.1 导入  
```Python  
try:
    import cPickle as pickle
except:
    import pickle
```  

- 7.1.2 编码和解码字符串数据  
**pickle.dumps()**将一个数据结构编码为一个字符串，默认情况下，pickle只包含ASCII字符。  
数据串行化后，可以写到一个文件、套接字或者管道等等，用**pickle.loads()**.

- 7.1.3 处理流  
pickle对于进程间通信也很方便，如：os.fork()和os.pipe()可以用来建立工作进程，从一个管道读取作业指令，并把结果写至另一个管道。管理工作线程池以及发送作业和接收响应的核心代码可以重用。  

- 7.1.5 不可pickle的对象  
套接字、文件句柄、数据库连接以及其他运行时状态依赖于操作系统或其他进程的对象可能无法用一种有意义的方式保存。此时可以用__getstate__()和__setstate__()来返回可pickle实例状态的一个子集。新式的类还可以定义__getnewargs__()，这会返回要传至类内存分配器(C.__new__())的参数。    


### 7.7 csv--逗号分隔值文件  

- 7.7.1 读文件  
读文件的时，输入数据的每一行都会解析，自动处理嵌在行字符串中的换行符，并转化为一个字符串list.
```Python
import csv
import sys

with open(sys.argv[1], 'rt') as f:
    reader = csv.reader(f)
    for row in reader:
        print row
```  

- 7.7.2 写文件  
使用writer()创建一个对象来写数据，然后使用writerow()迭代处理文本进行打印。  
```Python
import csv
import sys

with open(sys.argv[1], 'wt') as f:
    writer = csv.writer(f)
    writer.writerow(('Title 1', 'Title 2', 'Title 3'))

print open(sys.argv[1], 'rt').read()
Title 1, Title 2, Title 3

#引号需要加入额外参数，这里给出包含非数值内容的列周围加引号
writer = csv.writer(f, quoting=csv.QUOTE_NONNUMERIC)
"Title 1", "Title 2", "Title 3"
```  

- 7.7.3 方言  
由于用逗号分格文件有一定局限，可以将多个参数组在一起，构成一个方言(dialect)对象。  
```Python
# 示例一下注册方言，其他的用到再说  
import csv 

csv.register_dialect('pipes', delimiter='/')

with open('testdata.pipes', 'r') as f:
    reader = csv.reader(f, dialect='pipes')
    for row in reader:
        print row
```  

- 7.7.4 使用字段名  
csv中可以将航作为字典处理，从而对字段命名。DictReader和DictWriter类将行转换为字典而不是列表。字典的键可以传入，也可以由第一行推导得出(如果行包含首部).  
```Python
# 示例一下注册方言，其他的用到再说  
import csv 

csv.register_dialect('pipes', delimiter='/')

with open('testdata.pipes', 'r') as f:
    reader = csv.DictReader(f)
    for row in reader:
        print row
```  


# 第八章 数据压缩与归档  

### 8.4 tarfile--Tar归档访问  
和zipfile很相似，测试、读取、写入、追加等，虽然调用的函数名不一样，但逻辑是一样的，可以是对文件夹进行操作。


### 8.5 zipfile--ZIP归档访问  

- 8.5.1 测试ZIP文件  
is_Zipfile()函数返回一个bool值进行判断  

- 8.5.2 从归档读取元数据  
```Python
import Zipfile

with zipfile.ZipFile('example.zip', 'r') as zf:
    print zf.namelist()  # 以list形式返回压缩文件中的文件
```  
infolist()或getinfo()可以获得更多信息  

- 8.5.3 从归档抽取归档文件  
从一个归档成员中访问数据，可以使用read()方法。  

- 8.5.4 创建新归档  
```Python
from zipfile_infolist import print_info
import zipfile

with zipfile.ZipFile('write.zip', mode='w') as zf:
    zf.write('README.txt')  # 此处README.txt是一个文件

print_info('write.zip')
```  
想要增加压缩，需要用zlib模块。若zlib可用，可使用zipfile.ZIP_DEFLATED设置单个文件的压缩模式。  
```Python
from zipfile_infolist import print_info
import zipfile

try:
    import zlib
    compression = zipfile.ZIP_DEFLATED
except:
    compression = zipfile.ZIP_STORED

modes = { zipfile.ZIP_DEFLATED: 'deflated',
          zipfile.ZIP_STORED: 'stored',
}

with zipfile.ZipFile('write.zip', mode='w') as zf:
    mode_name = modes[compression]
    zf.write('README.txt', compress_type=compression)

print_info('write.zip')
```  
- 8.5.6 从非文件源写数据  
有时，数据并不是一个文件，可以用writestr()直接向归档写入一个字节串。  
```Python
from zipfile_infolist import print_info
import zipfile

msg = 'lol lol lol'

with zipfile.ZipFile('write.zip', mode='w', 
                      compression= zipfile.ZIP_DEFLATED,) as zf:
    zf.writestr('README.txt', msg)

print_info('write.zip')
```  

- 8.5.7 利用Zipinfo实例写  
可向writestr()传递一个ZipInfo实例，来定义修改日期和其他元数据。  

- 8.5.8 追加到文件  
mode='a'即可。  


# 第九章 加密  

### 9.1 hashlib--密码散列  
由于hashlib得到了OpenSSL的“支持”，OpenSSL库提供的所有算法都可用。像：md5,sha1,sha224,sha256,sha384,sha512.  
不过这个大家都知道怎么破解，文字加密比它强吧。  

- MD5  
```Python
In [1]: import hashlib

In [2]: h = hashlib.md5()  #sha1同理，用的是hashlib.sha1()

In [3]: l = 'gjj'

In [4]: h.update(l)

In [5]: h.digest()
Out[5]: '\xc8\xa9[\x06\x18\x19y0\xdf\xb55I!a}\xf5'

In [6]: h.hexdigest()
Out[6]: 'c8a95b0618197930dfb5354921617df5'
```  


# 第十章 进程与线程  

### 10.1 subprocess---创建附加进程  

- 10.1.1 运行外部命令  
函数call(),check_call()和check_output()都是Popen类的包装器。
```Python
In [1]: import subprocess

In [2]: subprocess.call(['ls', '-l'])  # ('ls -l')这种形式是错的呢
total 48
drwxrwxr-x 2 jblue13 jblue13 4096 Dec 22 18:11 code
drwxrwxr-x 2 jblue13 jblue13 4096 Sep  2 11:46 conversion
drwxrwxr-x 6 jblue13 jblue13 4096 Oct 29 14:37 demo
drwxr-xr-x 3 jblue13 jblue13 4096 Nov 25 16:23 Desktop
drwxrwxrwx 6 jblue13 jblue13 4096 Sep  9 13:25 detect_manga
drwxrwxr-x 6 jblue13 jblue13 4096 Nov  4 17:25 Jblue
drwxrwxr-x 7 jblue13 jblue13 4096 Sep 11 17:45 log_analyze
drwxrwxr-x 4 jblue13 jblue13 4096 Sep 11 17:04 logs
drwxrwxr-x 5 jblue13 jblue13 4096 Nov  1 13:55 manage
drwxr-xr-x 2 jblue13 jblue13 4096 Aug 14 10:20 Public
drwxrwxr-x 3 jblue13 jblue13 4096 Sep  6 13:34 src
drwxrwxr-x 3 jblue13 jblue13 4096 Sep  3 09:53 testvirtual
Out[2]: 0

In [4]: subprocess.call(['ls', '-l'], shell=True)
code  conversion  demo  Desktop  detect_manga  Jblue  log_analyze  logs  manage  Public  src  testvirtual
Out[4]: 0
```  
加上shell=True，意味着运行命令前会先处理命令串中的变量什么的。  
call()的返回值是程序的退出码，非0就是错，可以用check_call()来机型检查。  
```Python
try:
    subprocess.check_call(['false'])    
except subprocess.CalledProcessError as err:
    print 'ERROR:', err   
ERROR: Command '['false']' returned non-zero exit status 1
```  
对于call()启动的进程，其标准输入和输出通道会绑定到父进程的输入和输出。可以使用check_output()捕获输出  
```Python
In [9]: subprocess.check_output(["ls", "-l"])
Out[9]: 'total 48\ndrwxrwxr-x 2 jblue13 jblue13 4096 Dec 22 18:11 code\ndrwxrwxr-x 2 jblue13 jblue13 4096 Sep  2 11:46 conversion\ndrwxrwxr-x 6 jblue13 jblue13 4096 Oct 29 14:37 demo\ndrwxr-xr-x 3 jblue13 jblue13 4096 Nov 25 16:23 Desktop\ndrwxrwxrwx 6 jblue13 jblue13 4096 Sep  9 13:25 detect_manga\ndrwxrwxr-x 6 jblue13 jblue13 4096 Nov  4 17:25 Jblue\ndrwxrwxr-x 7 jblue13 jblue13 4096 Sep 11 17:45 log_analyze\ndrwxrwxr-x 4 jblue13 jblue13 4096 Sep 11 17:04 logs\ndrwxrwxr-x 5 jblue13 jblue13 4096 Nov  1 13:55 manage\ndrwxr-xr-x 2 jblue13 jblue13 4096 Aug 14 10:20 Public\ndrwxrwxr-x 3 jblue13 jblue13 4096 Sep  6 13:34 src\ndrwxrwxr-x 3 jblue13 jblue13 4096 Sep  3 09:53 testvirtual\n'

#加上shell=True，和在call里面效果一样
In [12]: subprocess.check_output(["ls", "-l"], shell=True)
Out[12]: 'code\nconversion\ndemo\nDesktop\ndetect_manga\nJblue\nlog_analyze\nlogs\nmanage\nPublic\nsrc\ntestvirtual\n'

#加上stderr=subprocess.STDOUT，如果出错，错误信息将不会输出到控制台
In [13]: subprocess.check_output(["ls", "-l"], shell=True, stderr=subprocess.STDOUT)
Out[13]: 'code\nconversion\ndemo\nDesktop\ndetect_manga\nJblue\nlog_analyze\nlogs\nmanage\nPublic\nsrc\ntestvirtual\n'
```  

- 10.1.2 直接处理管道  
要运行一个进程并读取它的所有输出，可以设置stdout值为PIPE并调用communicate().  
```Python
In [5]: p = subprocess.Popen('ls', stdout=subprocess.PIPE)

In [6]: s = p.communicate()[0]

In [7]: s
Out[7]: 'code\nconversion\ndemo\nDesktop\ndetect_manga\nJblue\nlog_analyze\nlogs\nmanage\nPublic\nsrc\ntestvirtual\n'
```  
要把数据一次性发送到进程的标准输入通道，可以把数据传递到communicate().  
```Python
In [9]: p = subprocess.Popen(['cat', '-'], stdin=subprocess.PIPE)

In [10]: p.communicate('\tstdin: to stdin\n')
    stdin: to stdin
Out[10]: (None, None)
```  
类似的，还有错误捕捉。不过要将错误输出从进程定位到标准输出通道，应是**stderr=subprocess.STDOUT**  

- 10.1.3 连接管道段  
多个命令可以连接为一个管线(pipeline),类似于UNIX shell的做法，即单独创建Popen实例，把它们的输入和输出串联在一起。一个Popen实例的stdout属性用作管线中下一个Popen实例的stdin参数，而不是常量PIPE。
```Python
In [11]: cat = subprocess.Popen(['cat', 'index.txt'], stdout=subprocess.PIPE)

In [12]: gerp = subprocess.Popen(['grep','..include::'], stdin=cat.stdout, stdout=subprocess.PIPE)
```  

- 10.1.5 进程间传递信号  
信号由signal模块获得，sys.stout.flush()进行刷新。  
因为Popen创建的进程创建了子进程，这些子进程不会接收发送父进程的信号。所以进行进程组通信，让子进程也能接受信号。进程组用os.setsid()创建，将“会话id”设置为当前进程的进程id。所有的子进程都会从其父进程继承会话id。
```Python
import os
import signal
import subprocess
import tempfile
import time
import sys

script = '''#!/bin/sh
echo "Shell script in process $$"
set -x
python signal_child.py
'''
script_file = tempfile.NamedTemporaryFile('wt')
script_file.write(script)
script_file.flush()

def show_setting_sid():
    print 'Calling os.setsid() from %s'% os.getpid()
    sys.stdout.flush()
    os.setsid()

proc = subprocess.Poen(['sh', script_file.name],
                        close_fds=True,
                        preexec_fn=show_setting_sid)
sys.stdout.flush()
print 'Signaling process group %s'%proc.pid
sys.stdout.flush()
os.killpg(proc.pid, signal.SIGUSR1)
time.sleep(3)
```  

### 10.3 threading--管理并发操作  

- 10.3.1 Thread对象  
实例化一个Thread对象，并调用start()让它开始工作。  

- 10.3.2 确定当前线程  
```Python
import threading
threading.currentThread().getName()  
```  

- 10.3.3 守护与非守护线程  
win没法用，暂时先学习着吧。要标志一个线程为守护县城，需调用setDaemon()方法，并提供参数True。  
```Python
import threading

d = threading.Thread(name='deamon', target=deamon)
d.setDaemon(True) 
```  

- 10.3.4 列举所有线程  
```Python
import threading

main_thread = threading.currentThread()
for t in threading.enumerate():
    if t in main_thread:
        continue
    t.join() 
```  

- 10.3.8 控制资源访问  
使用Lock对象进行处理。  



### 10.4 multiprooessing--像线程一样管理进程  

- 10.4.1 multiprocessing基础  
```Python
import multiprocessing 

def worker(num):
    print 'worker;', num
    return 

if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=worker, args=(i,))
        jobs.append(p)
        p.start()

worker; 0
worker; 1
worker; 2
worker; 3
worker; 4
```  

- 10.4.2 可导入的目标函数  
threading与multiprocessing例子之间有一个区别，multiprocessing对__main__使用了额外的保护。由于新进程启动的方式，要求子进程能够导入包含目标函数的脚本。可以将应用的主要部分包装在一个__mian__检查中，确保模块导入时不会在各个子进程中递归运行。  

- 10.4.3 确定当前进程  
每个Process实例都有一个名称，其默认值可以在创建进程时改变。  
```Python
import multiprocessing 
import time 

def worker():
    name = multiprocessing.current_process().name
    print name, 'Staring'
    time.sleep(2)
    print name, 'Exiting'

def my_service():
    name = multiprocessing.current_process().name
    print name, 'Starting'
    time.sleep(3)
    print name, 'Exiting'

if __name__ == '__main__':
    service = multiprocessing.Process(name='my_service', target=my_service)
    worker_1 = multiprocessing.Process(name='worker 1', target=worker)
    worker_2 = multiprocessing.Process(target=worker)

    worker_2.start()
    worker_1.start()
    service.start()

Process-3 Staring
worker 1 Staring
my_service Starting
worker 1 Exiting
Process-3 Exiting
my_service Exiting
```  

- 守护进程  
```Python
import multiprocessing 
import time 
import sys 

def daemon():
    p = multiprocessing.current_process()
    print 'Staring:', p.name, p.pid
    sys.stdout.flush()
    time.sleep(2)
    print 'Exiting:', p.name, p.pid
    sys.stdout.flush()  

def non_demon():
    p = multiprocessing.current_process()
    print 'Staring:', p.name, p.pid
    sys.stdout.flush()
    print 'Exiting:', p.name, p.pid
    sys.stdout.flush()  

if __name__ == '__main__':
    d = multiprocessing.Process(name='daemon', target=daemon)
    d.daemon = True

    n = multiprocessing.Process(name='non-daemon', target=non_demon)
    n.daemon = False

    d.start()
    time.sleep(1)
    n.start()

Staring: daemon 26180
Staring: non-daemon 26184
Exiting: non-daemon 26184
```  
守护进程会在主程序退出之前自动终止，以避免留下“孤”进程继续运行。  

- 10.4.5 等待进程  
要等待一个进程完成工作并退出，可以使用join()方法。默认情况下，join()会无限阻塞。可以传入
一个超时参数。即使进程在这个超时期限内没有完成，join()也会返回。PS：**如果传入的超时值小于守护进程睡眠的时间，所以join()返回之后这个进程仍“存活”**  

- 10.4.6 终止进程  
如果一个进程看起来已经挂起或陷入死锁，则需要能够强制将其结束，即对一个进程对象调用terminare()。  
```Python
import multiprocessing 

if __name__ == '__main__':
    d = multiprocessing.Process(target=slow_worker)
    
    d.start()
    d.terminate()
    d.join()
```  
注意：**终止进程后要使用join()退出进程，使进程管理代码有时间更新对象的状态。**  

- 10.4.7 进程退出状态  
| 退出码 | 含义   
| ------ | --------------------------------  
| ==0    | 未生成任何错误  
| >0     | 进程有一个错误，并以该错误码退出  
| <0     | 进程有一个-1*exitcode信号结束  

- 10.4.8 日志  
multiprocessing.log_to_stderr()使用logging建立一个日志记录器对象，并增加一个处理程序，使得日志消息将发送到标准错误通道。  

- 10.4.9 派生进程  
```Python
import multiprocessing 

class Worker(multiprocessing.Process):

    def run(self):
        print 'In %S'% self.name 
        return 

if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = Worker()
        jobs.append(p)
        p.start()
    for j in jobs:
        j.join()
```  

- 10.4.10 向进程传递消息  
multiprocessing.Queue()来回递消息。  

- 10.4.11 进程间信号传输  
Event类，通过使用一个可选的超时值，事件对象可以等待其状态从未设置变为设置。  

- 10.4.14 控制资源的并发访问  
创建一个连接池，Manager创建的特殊类型列表对象集中维护活动进程列表,Manager负责协调其所有用户之间的共享信息状态。除了列表和字典之外，Manager还可以创建一个共享Namespace。  

- 10.4.17 进程池  
Pool类来管理固定数目的工作进程，pool参数包括进程数以及启动任务进程时要进行的函数.pool.map()方法等价于内置map()，只不过单个任务会并行运行。  


# 第十一章 网络通信  

### 11.1 socket--网络通信  

- 11.1.1 寻址、协议簇和套接字类型  
套接字(socket)是程序在本地或者通过互联网来回传递数据时所用通信通道的一个端点。套接字有两个主要属性来控制如何发送数据:地址簇(address family)控制所用的OSI网络协议，套接字类型(socket type)控制传输层协议。  
查找当前主机名字：gethostname();gethostbyname()将服务器名字转换为其数字地址；getservbyname()可以用网络服务的端口号和标准名查找。  



# 第十二章 Internet  

### 12.3 urllib--网络资源访问  
关于网络爬虫方面，我一般都是选择requests+lxml+re，自己写。  

- 12.3.1 利用缓存实现简单获取  
可以用urlretrieve()，urlretrieve(url, filename=None, reporthook=None, data=None)，调用reporthook()报告下载进度。  

- 12.3.2 参数编码  
urlencode()函数可以做到。  

- 12.3.3 路径与URL  
pathname2url()和url2pathname()之间可以来回切换，ipython里面试了下，感觉没啥。


### 12.4 urllib2--网络资源访问  

- 12.4.1 HTTP GET  
将URL传入urlopen()中，针对其返回值，info()方法从HTTP服务器访问首部，可使用read()和readlines()等方法访问远程资源。  

- 12.4.3 HTTP POST  
需要将编码的查询参数作为数据传入urlopen()中，即用到urllib.urlencode()。  

- 12.4.4 增加发出首部  
即增加u-a信息。  

- 12.4.6 上传文件  
在请求体中构造一个完整的MIME消息。  
```Python
import mimetools
import mimetypes
```  


### 12.9 json--JavaScript对象记法  

- 12.9.2 优质输出和紧凑输出  
```Python
import json

#dumps()函数接受多个参数，sort_keys标志会告诉编码器按有序顺序而不是随机顺序输出字典的键。  
json.dumps(data, sort_keys=True)

#indent用来制定一个缩进。  
json.dumps(data, sort_keys=True, indent=2)
```  

- 12.9.5 编码器和解码器类  
JSONEncoder使用一个可迭代接口生成编码数据“块”，从而更容易写至文件或网络套接字。  

- 12.9.7 混合数据流  
JSONDecoder包含一个raw_decode()方法。


# 第十四章 应用构建模块  

### 14.7 shlex--解析shell  
- 加引号的字符串
```Python
In [1]: import shlex

In [2]: s = 'This string has embedded "double quotes" and \'single quotes\' in it,\nand even "a \'nested example\'".\n'

In [6]: for i in a:
   ...:     print repr(i)
   ...:     
'This'
'string'
'has'
'embedded'
'"double quotes"'
'and'
"'single quotes'"
'in'
'it'
','
'and'
'even'
'"a \'nested example\'"'
'.'
```  

- 14.7.2 嵌入注释  
默认情况下，#后面的文本会认为是注释的一部分，并被忽略。由于解析器的特点，它只支持单字符注释前缀。可以通过commenters属性配置使用的注释字符集。  

- 14.7.3 分解  
要把一个现有字符串分解为其组成token，可使用便利函数split()。  
```Python
In [1]: import shlex

In [2]: s = 'This string has embedded "double quotes" and \'single quotes\' in it,\nand even "a \'nested example\'".\n'

In [7]: shlex.split(s)
Out[7]: 
['This',
 'string',
 'has',
 'embedded',
 'double quotes',
 'and',
 'single quotes',
 'in',
 'it,',
 'and',
 'even',
 "a 'nested example'."]

##或许这是一个小技巧来的##
>>> subprocess.Popen(shlex.split('ls -l'))  
total 8
-rw-r--r--. 1 root root 324 Sep  8 07:15 shlex_one.py
-rw-r--r--. 1 root root  99 Sep  8 07:16 text.str
```  

- 14.7.4 包含其他Token源  
shlex类包括很多配置属性来控制其行为。source属性可以启用代码(或配置)重用特性，允许一个token流包含另一个token流。  

- 14.7.5 控制解析器  
可以设置quotes字符来使用额外或替代引号。每个引号必须是单个字符，所以不可能有不同的开始和结束引号。  


### 14.9 日志--报告状态、错误和信息消息  

- 14.9.2 记入文件  
basicConfig()函数建立默认处理器。  

- 14.9.3 旋转日志文件  
想每次程序运行时创建一个新文件，可以向basicConfig()的参数filemode传入值“w”，有更好的做法是使用一个RotatingFileHandler，它会自动创建新文件，同时保留原来的日志文件。  
```Python
import glob
import logging
import logging.handlers 

log_file = 'lol.out'

my_logger = logging.getLogger('MyLogger')
my_logger.setLevel(logging.DEBUG)

handler = logging.handlers.RotatingFileHanler(log_file,
                                              maxBytes=20,
                                              backupCount=5,)

my_logger.addHandler(handler)

for i in range(20):
    my_logger.debug('i=%d'%i)

logfiles = glob.glob('%s*'%log_file)
for filename in logfiles:
    print filename
```  

### 14.11 atexit--程序关闭回调  
atexit模块提供了一个接口，来注册程序正常关闭时调用的函数。sys模块还提供了一个hook，sys.exitfunc，不过这里只能注册一个函数。atexit注册表可以由多个模块和库同时使用。  

- 14.11.1 示例  
```Python
import atexit 

def all_done():
    print 'lol'

atexit.register(all_done)
```  
可以注册多个函数，并向注册的函数传递参数。PS:**退出函数时会按注册的逆序来调用**  

- 14.11.3 处理异常  
atexit回调中所产生异常的Traceback会打印到控制台上。  


# 第十六章 开发工具  

### 16.3 unittest--自动测试框架  

- 16.3.1 基本测试结构  
```Python
import unittest

class SimplisticTest(unittest.TestCase):
    
    def test(self):
        self.failUnless(True)

#运行是加上-v，可以查看用时
if __name__ == "__main__":
    unittest.main()
```  

- 16.3.4 断言真值  
```Python
import unittest

class TruthTest(unittest.TestCase):
    
    def testFailUnless(self):
        self.failUnless(True)
    def testAssertTrue(self):
        self.assertTrue(True)

    def testFailIf(self):
        self.failIf(True)
    def testAssertFalse(self):
        self.assertFalse(False)

if __name__ == "__main__":
    unittest.main()
```  



### 16.4 traceback---异常和栈轨迹  
This module provides a standard interface to extract, format and print stack traces of Python programs. It exactly mimics the behavior of the Python interpreter when it prints a stack trace. This is useful when you want to print stack traces under program control, such as in a “wrapper” around the interpreter.  

- 16.4.2 处理异常  
print_exc()使用sys.exc_info()来得到当前线程的异常信息，格式化结果，并把文本打印到一个文件句柄(默认为sys.stderr)。
```Python
import traceback
import sys

try:
    xxx
except Exception, err:
    traceback.print_exc(file=sys.stdout)
```  
print_exc()是print_exception()缩写，使用它需要三个显示参数:**异常类型、异常值和traceback**，与之相似的是format_exception()，后者主要用于准备文本。
```Python
import traceback
import sys

try:
    xxx
except Exception, err:
    exc_type, exc_value, exc_tb = sys.exc_info()
    traceback.print_exception(exc_type, exc_value, exc_tb)

try:
    xxx
except Exception, err:
    exc_type, exc_value, exc_tb = sys.exc_info()
    pprint(traceback.format_exception(exc_type, exc_value, exc_tb))
```  
traceback.extract_tb()返回值是一个项列表，每一项是一个元组，包括4部分：**源文件名、该文件中的行号、 函数名和该行的源文本**  

- 16.4.3 处理栈  
print_stack()是对当前调用栈而不是traceback完成的操作，会打印当前栈，而不是报错。与之对应的还有format_stack(),extrack_stack()类似于extract_tb()。  

### 16.6 pdb--交互式调试工具  
> 本章已做过学习  

- 16.6.1 启动调试工具  
调试失败后称为事后剖析调试，pdb通过pm()和post_mortem()函数支持事后剖析调试。  



# 第十七章 运行时特性  

### 17.2 sys--系统特定的配置  

- 17.2.1 解释器设置  
sys.hexversion     获取Python解释程序的版本值，16进制格式如：0x020403F0  
sys.version        获取Python解释程序的版本信息   
sys.api_version    解释器的C的API版本   
sys.version_info   版本信息  
sys.subversion     获取解释器  
sys.platform       返回操作系统平台名称   
sys.flags          获取命令行的参数  
sys.displayhook    每次进入Ipython，都会先调用这个  
sys.executable     获取Python解释程序路径   
sys.prefix         指示解释器安装的父目录  
sys.getwindowsversion()      获取Windows的版本   
sys.getdefaultencoding()     得到解释器的默认编码值。  
**ps：这个值在启动时由site设置，它会调用sys.setdefaultencoding(),然后从sys的命名空间将其删除。  
sys.getfilesystemencoding()  会返回一个操作系统特定的值.  
```Python
In [1]: import sys

In [2]: sys.version
Out[2]: '2.7.6 (default, Jun 22 2015, 17:58:13) \n[GCC 4.8.2]'

In [3]: sys.hexversion
Out[3]: 34014960

In [4]: sys.api_version
Out[4]: 1013

In [5]: sys.version_info
Out[5]: sys.version_info(major=2, minor=7, micro=6, releaselevel='final', serial=0)

In [6]: sys.subversion
Out[6]: ('CPython', '', '')

In [9]: sys.platform
Out[9]: 'linux2'

In [10]: sys.flags
Out[10]: sys.flags(debug=0, py3k_warning=0, division_warning=0, division_new=0, inspect=0, interactive=0, optimize=0, dont_write_bytecode=0, no_user_site=0, no_site=0, ignore_environment=0, tabcheck=0, verbose=0, unicode=0, bytes_warning=0, hash_randomization=0)
In [11]: sys.flags.debug
Out[11]: 0

In [13]: sys.getdefaultencoding()
Out[13]: 'ascii'

In [14]: sys.getfilesystemencoding()
Out[14]: 'UTF-8'

In [15]: sys.displayhook
Out[15]: <IPython.core.displayhook.DisplayHook at 0x7fb8ffe63150>  

In [17]: sys.executable
Out[17]: '/usr/bin/python'

In [18]: sys.prefix
Out[18]: '/usr'

```  

- 17.2.2 运行时环境  
sys.argv       可以获得外部的命令行参数  
sys.stdout     标准输出  
sys.stdin      标准输入   
sys.stderr     错误输出  
sys.exit(n)    退出程序，正常退出时exit(0)  

- 17.2.3 内存管理和限制  
python使用引用计数(reference counting)和垃圾回收(garbage collection)来完成自动内存管理。一个对象的引用数降至0时，他会自动标志为回收。要查看一个现有对象的引用数,可使用**sys.getrefcount()**.  
sys.getsizeof()可以获知一个对象有多少引用，从而帮助发现环或内存泄漏。  
对于一个类所用的空间，要得到更全面的估计，模块提供一个__sizeof__()方法来计算这个值，它会累计一个对象各个属性的大小。  
```Python
import sys

class WithAttributes(object):
    def __init__(self):
        self.a = 'a'
        self.b = 'b'
        return

    def __sizeof__(self):
        return object.__sizeof__(self) + \
            sum(sys.getsizeof(v) for v in self.__dict__.values())
```  
这个版本将对象的基本大小加上存储在内部__dict__中的所有属性的大小来计算对象大小。  
python应用中允许无限递归，可能会引入解释器本身的栈溢出，导致崩溃。为了消除这种情况，可使用sys.setrecursionlimit()和sys.getrecursionlimit().  
sys.maxint     最大的Int值
sys.maxint     是列表、字典、串、或C解释器中size类型指示的其他数据结构的最大大小。  
sys.maxint     当前配置的解释器支持的最大证书Unicode值。  
sys.float_info 包含解释器所用的浮点数类型表示(基于底层系统的float实现)  

- 17.2.4 异常处理  
sys.excepthook()设置为一个函数，它有3个参数(错误类型、错误值和traceback).
sys.exc_info()用来获取线程的当前异常，返回值是一个包含3个成员的元组，其中包含异常类、异常实例和traceback。它是线程安全的  

- 17.2.5 底层线程支持  
Python存在GIL，字节码执行一个固定的间隔暂停，解释器则检查是否需要执行某个信号处理器。在这个间隔检查期间，当前线程会释放GIL，然后重新请求，使其他线程有机会先获得这个锁来得到执行权。  
默认的检查间隔是100字节码，可以用**sys.getcheckinterval()**得到当前值，用**sys.setcheckinterval()**改变这个间隔(慎用！！！)。  
**sys._current_frames()**能准确地显示出线程在哪里停止。  

- 17.2.6 模块和导入  
sys.modules是一个字典，将所导入模块的名字映射为包含具体代码的模块对象。  
sys.builtin_module_names可以导入内置模块  

- 17.2.7 跟踪程序运行情况  
有两种方式注入代码，来监视一个程序的运行，包括跟踪(tracing)和性能分析(profiling)。监视一个程序最容易也最低效的方法是通过一个跟踪hook(trace hook),可以用它来编写一个调试工具、监视代码覆盖或其他的目的。  
可以向sys.settrace()传递一个回调函数修改跟踪hook.这个回调接收3个函数：所运行代码的栈帧、命名通知类型的串，以及一个事件特定的参数值。  
使用hook的另一种有用的方法是跟踪正在调用哪些函数，以及它们的返回值是什么。要监视返回值，可以见识return事件。  



### 17.3 os--可移植访问操作系统特定特性  

- 17.3.1 进程所有者  
```Python
#!/usr/bin/env python
# coding=utf-8
import os

TEST_GID = 501
TEST_UID = 527

def show_user_info():
    print 'User (actual/effective): %d/%d'%\
            (os.getuid(), os.geteuid())
    print 'Group (actual/effective): %d/%d'%\
            (os.getgid(), os.getegid())
    print 'actual Groups : ', os.getgroups()
    return 

print 'Before CHANGE:'
show_user_info()
print 

try:
    os.setegid(TEST_GID)
except OSError:
    print 'ERROR: Could not vhange effective group. Return as root.'
else:
    print 'CHANGED GROUP:'
    show_user_info()
    print

try:
    os.setegid(TEST_UID)
except OSError:
    print 'ERROR: Could not vhange effective group. Return as root.'
else:
    print 'CHANGED USER:'
    show_user_info()
    print

Before CHANGE:
User (actual/effective): 1000/1000
Group (actual/effective): 1000/1000
actual Groups :  [4, 24, 27, 30, 46, 108, 124, 1000]

ERROR: Could not vhange effective group. Return as root.
ERROR: Could not vhange effective group. Return as root.
```  
可见，进程值并未改变，当然如果是sudo启动仅可以啦。  

- 17.3.2 进程环境  
环境中设置的变量作为字符串可见，这些字符串可以通过os.environ() or os.getenv()读取。  
```Python
In [1]: import os

In [5]: os.environ
Out[5]: {'USER': 'jblue13', 'MANDATORY_PATH': ...}

In [6]: os.getenv
Out[6]: <function os.getenv>
```  

- 17.3.3 进程工作目录  
如果操作系统有层次结构的文件系统，会有一个“当前工作目录”的概念，使用相对路径访问文件时，进程将使用文件系统上的这个目录作为起始位置。当前目录可以用os.getcwd()获取，用os.chdir()改变。  
```Python
In [1]: import os

In [8]: os.getcwd()
Out[8]: '/home/jblue13'

In [9]: os.pardir
Out[9]: '..'

In [10]: os.chdir(os.pardir)

In [11]: os.getcwd()
Out[11]: '/home'
```  

- 17.3.4 管道  
这一块可以使用subprocess取代，最常用的管道函数是popen().它创建一个新进程运行指定命令，并根根据模式(mode)参数，为该进程的输入或输出关联一个流。  

- 17.3.6 文件系统权限  
关于文件的详细信息可以使用os.stat() or os.lstat()访问。  
```Python
In [1]: import os

In [13]: os.stat('/home/')
Out[13]: posix.stat_result(...)

In [14]: os.lstat('/home/')
Out[14]: posix.stat_result(...)
```  
在类UNIX的系统上，可以使用chmod()改变文件权限，只需传入模式(一个整数)。模式值可以使用stat模块中定义的常量来构造。  

- 17.3.7 目录  
创建一个目录可以使用os.mkdir(),所有父目录都必须已经存在。  
用os.rmdir()删除一个目录时，实际上只会删除叶子目录(路径的最后一部分)。  
os.makedirs()和os.removedirs()要处理路径中的所有节点。os.makedirs()会创建路径上所有不存在的部分，os.removedirs()将删除所有父目录(只要他们为空)。  

- 17.3.8 符号链接  
os.symlink(source, link_name)：为源文件source创建一个符号链接link_name。  
```Python
In [1]: import os

In [16]: os.symlink('/home/jblue13/lol.py','/home/jblue13/ln_filename')  # 出现了名字为ln_filename一个快捷方式
```  
os.readlink()可以读取符号链接来确定由该链接指示的原始文件。  

- 17.3.9 遍历目录树  
walk(top, topdown=True, onerror=None, followlinks=False)  
以自顶向下遍历目录树或者以自底向上遍历目录树，对每一个目录都返回一个三元组(dirpath, dirnames, filenames)。  
dirpath - 遍历所在目录树的位置，是一个字符串对象  
dirnames - 目录树中的子目录组成的列表，不包括("."和"..")  
filenames - 目录树中的文件组成的列表  
如果可选参数topdown = True或者没有指定，则其实目录的三元组先于其子目录的三元组生成(自顶向下生成三元组)，如果topdown = False，则起始目录的三元组在其子目录的三元组生成后才生成(自底向上生成三元组)。  
当topdown = True，os.walk()函数会就地修改三元组中的dirnames列表(可能是使用del或者进行切片），然后再使用os.walk()递归地处理剩余在dirnames列表中的目录。这种方式有助于加快搜索效率，可以指定特殊的遍历顺序。当topdown = False的时候修改dirnames是无效的，因为在使用自底向上进行遍历的时候子目录的三元组是先于上一级目录的三元组创建的。  

- 17.3.11 用os.fork()创建进程  
win下无法用，作用是创建一个新进程,作为当前进程的一个克隆。创建之后，这两个进程运行同样的代码。程序要像分辨在哪一个进程中，需要检查fork()的返回值。如果值是0，当前进程是子进程；如果不是0，说明程序在父进程中运行。 返回值就是子进程的进程id。  
父进程可以使用kill()和signal模块像子进程发送信号。  

- 17.3.12 等待子进程  
```Python
wait(...)
wait() -> (pid, status)
    
Wait for completion of a child process.
```  

- 17.3.13 Spawn  
spawn()系列函数可以在一个语句中完成fork()和exec()处理。  

- 17.3.14 文件系统权限  
os.access(path, mode)：使用实际的uid和gid去测试路径的访问权。实际的uid和gid指的是用户登录到系统使用的uid和当前用户所在的gid，这和有效用户id和有效组id是有区别的，有效用户id和有效组id是对应于进程的。  
mode参数指定测试路径的方式：  
os.F_OK - 测试路径是否存在  
os.R_OK - 测试文件是否可读  
os.W_OK - 测试文件是否可写  
os.X_OK - 测试文件是否可执行  
其中的R_OK，W_OK，X_OK是可以使用OR操作合起来进行一起测试的。  
函数返回True如果测试成功，否则返回False。在系统的C API中可以使用access系统调用。  