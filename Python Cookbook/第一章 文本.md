#第一章 文本
---
**基本的文本操作**<br/>
- 解析数据并将数据放入程序内部的结构中；<br/>
- 将数据以某种方式转化为另一种相似的形式，数据本身发生了改变；<br/>
- 生成全新的数据。<br/>
**字符串基础**<br/>
Python提供的用于文本处理的最主要的工具就是字符串--不可改变的字符序列。实际上包含两种字符串：<br/>
*普通字符串*：包含8位(ASCII)字符，仅有256个不同字符；<br/>
*Unicode字符串*：包含Unicode字符，有无数个。<br/>
在字符串前加个**r**或**R**，将表示出字符串原本的输入，如\将不会换行。加**u**或**U**会成为Unicode字符串。<br/>
---
**1.2 字符和字符值之间的转换**<br/>
*ord*: str -> ASCII or unicode -> str  *chr*: ASCII -> str  *unichr* : str -> unicode<br/>

**1.3 测试一个对象是否是类字符串**<br/>
instance可以做到这个，然而对于UserString没有效果，所以我们需要检查一个对象的行为是否真的像字符串一样。<br/>
```python
def isStringLike(anobj):
    try:
        anobj.lower() + anobj + ' '
    except:
        return False
    else:
        return True 
```
Python中类型检查常用鸭子判断法：如果它走路像鸭子，叫声像鸭子，就可以认为它是鸭子了。另外根据自己的语气去执行任务，在此过程中检测并处理由于不匹配产生的所有错误和异常。这种处理方式称为：*EAFP：It's easier to ask forgiveness than permission.*，try/except是保证该风格的关键工具。<br/>
对于2.X版本：Python文档中提到，如果不涉及到2.2以前的版本，请考虑直接使用str类型来代替UserString类型。<br/>
对于3.X版本：该模块已经移到collection模块中。 <br/>

**1.8 检查字符串中是否包含某字符集合中的字符**<br/>
除了常规的for+if循环外，可以使用set().difference()来处理。其语义为任何一个set对象a，a.difference(b)(就像a-set(b))返回a中所有不属于b的元素。<br/>

**1.9 简化字符串的translate方法的使用**<br/>
S.translate(table [,deletechars]) -> string：<br/>
table -- 翻译表，翻译表是通过maketrans方法转换而来。deletechars -- 字符串中要过滤的字符列表。<br/>
书中给出作者写的一个叼炸天的类，用的工厂闭包的形式：
```python
import string
def translator(frm='', to='', delete='', keep=None):
    if len(to) == 1:
        to = to * len(frm)
    trans = string,maketrans(frm, to)
    if keep is not None:
        allchars = string.maketrans('', '')
        delete = allchars.translate(allchars, keep.translate(allchars,delete))
    def translate(s):
        return s.translate(trans, delete)
    return translate 
>>>d = translator(keep=string.digits)
>>>d("ch : 22-12")
'2212'
>>>n = translator(delete=string.digits)
>>>n("ch : 22-12")
'ch : -'
```

**1.10 过滤字符串中不属于指定集合的字符**<br/>
translate应用于一个字符串返回该字符串的一个拷贝，这个拷贝中所有的字符都将按照传入的第一个参数(翻译表)指定的替换方式来替换，而且，第二个参数指定的所有字符都将被删除。maketrans是创建翻译表的一个工具函数。<br/>
```python
import string
allchars = string.maketrans('', '')
def makefilter(keep):
    delchars = allchars.translate(allchars, keep)
    def thefilter(s):
        return s.translate(allchars, delchars)
    return thefilter 
```

**1.14 改变多行文本字符串的缩进**<br/>
```python
def addspace(s, numAdd):
    white = ""*numAdd
    return white + white.join(s,splitlines(True))
def numSpaces(s):
    return [len(line) - len(line.lstrip()) for line in s.splitlines()]
def delSpaces(s, numDel):
    if numDel > min(numSpaces(s)):
        raise ValueError, "remove"
    return '\n'.join([line[numDel:] for line in s.splitlines()])
```
splitlines与split相比，它保留了每行的换行符。<br/>

**1.19 检查字符串中的结束标记**<br/>
可以用s.endswith(end1),作者给出另外一种模式：<br/>
```python
import itertools
def anyTrue(predicate, sequence):
    return True in itertools.imap(predicate, sequence)
def endsWith(s, *endings):
    return anyTrue(s.endswith, endings)
```
辅助函数anyTrue是一个通用而快速的函数，可以给它传入其他的被绑定方法(bound method)作为第一个参数，比如s.startswith或s.__contains__。事实上，不使用辅助函数直接编码也许更好：<br/>
```python
if anyTrue(filename.endswith, (".jpg", ".gif", ".png")):
```

**1.20 使用Unicode来处理国际化文本**<br/>
- 无论何时，当你的程序接收到来自"外部"的文本数据(来自网络，文件，或者用户输入等)时，应当立即创建一个Unicode对象，找出最适合的编码，如查看HTTP头，或者寻找一个适合的转化方法来确定所用的编码方式。<br/>
- 无论何时，当你的程序需要向"外部"发送文本数据(发送网络， 写入文件， 或者输出给用户等)时，应当立刻创建一个unicode对象，应当探查正确的编码，并用那种编码将你的文本转化为字符串。(否则，Python会尝试把Unicode转成ASCII字符串，这很有可能发生UnicodeEncodeError异常)<br/>


